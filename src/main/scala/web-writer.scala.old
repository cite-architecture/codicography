package edu.furman.classics.scwidget

import better.files._
import java.io.{File => JFile}
import edu.holycross.shot.cite._
import edu.holycross.shot.scm._
import edu.holycross.shot.citeobj._
import edu.holycross.shot.citerelation._
import edu.holycross.shot.dse._
import edu.holycross.shot.ohco2._
import edu.furman.classics.citewriter._
import scala.annotation.tailrec
import scala.io.Source

/** An object that writes a facsimile view of a CEX file that implements the DSE datamodel */
object webWriter {

  case class FacsimilePage(
    html: String,
    prevFile: Option[String],
    prevLabel: Option[String],
    nextFile: Option[String],
    nextLabel: Option[String],
    howMany: Int,
    index: Int,
    fileName: String,
    title: String 
  )



  /** Our main function where the action happens */
  def xmain(args: Array[String]) {
  		// Find out of the user typed the right command to launch this!

  		// Get the parameters that came with 'run'
  		val params: Vector[String] = args.toVector
  		val libraryPath: Option[String] = {
  			if ( params.size > 0 ) Some(params.head)
  			else {
  				println(s"""\n------\nRunning with default config: configs/config.txt.\n\nTo specify a different config file, type 'run path/to/config.txt'.\n------\n""")
  				Some("configs/config.txt")
  			}
  		}
  		libraryPath match {
  			case Some(lp) => {
  				 if (lp.endsWith(".txt")) makePages( lp )
  				 else {
  				 	println(s"""\n------\nParameter `${lp}` does not seem to be a Unix path to a .txt config file.\n------\n""")
  				 }
  			}
	  		case None => // do nothing
  		}
  		
  }

  def getConfig( f: String): Option[Map[String, String]] = {
    try {
      val configString: Vector[String] = utilities.loadFile(f).filter(_.size > 0).filter( _.contains("#")).filter ( _.take(2) != "//")
      val cm: Map[String, String] = configString.map( s => {
        val k = s.split("#").toVector.head
        val v = s.split("#").toVector.last
        (k -> v)
      }).toMap
      Some(cm)
    } catch {
      case e: Exception => {
         println(s"Error getting config file: ${e}")
         None 
      }
    }
  }

  /** the `main` function kicks it off, but the real work happens here… */
  def makePages( configPath: String ): Unit = {

  	try {

				/* Steps */
				// 1. Get our Data…
      val config: Option[Map[String, String]] = getConfig(configPath)
      val cexFile: String = config.get("cexPath")
      val htmlPath: String = config.get("htmlPath")
      lazy val lib: CiteLibrary = utilities.loadLibrary(cexFile)
      lazy val tr: TextRepository = lib.textRepository.get
      lazy val corp: Corpus = tr.corpus
      lazy val cat: Catalog = tr.catalog
      lazy val colls: CiteCollectionRepository = lib.collectionRepository.get
      lazy val rels: CiteRelationSet = lib.relationSet.get
      val dseVec: DseVector = DseVector.fromCiteLibrary(lib)
			/* -------------------------------------- */
      /* -------------------------------------- */
      /* For now, write three pages */
      val surfaceUrns: Vector[Cite2Urn] = dseVec.passages.take(3).map(_.surface)
      val facsObjects: Vector[FacsimilePage] = {
        makeFacsObjects(surfaceUrns, colls, corp, dseVec, config.get)
      }
      // Clear directory
      val htmlDirPath: String = config.get("htmlPath")
      val htmlDir: File = File(htmlDirPath)
      htmlDir.clear()
      // Write files
      for ( o <- facsObjects) {
        val pageHtml: String = assembleHtml(o, config.get)
        utilities.saveString( pageHtml, htmlDirPath, o.fileName)
      }

      /* -------------------------------------- */
      /* -------------------------------------- */
    } catch {
			case e: Exception => {
  			println(s"""\n-----\nBuilding the site failed with the following error: \n\n${e}\n\n-----\n)""")
			}
    }
  }

  /** Turn a vector of Surface URNs into a Vector
   *  of FacsimilePage objects
   */
  def makeFacsObjects(
    surfaceUrns: Vector[Cite2Urn], 
    colls: CiteCollectionRepository,
    corp: Corpus,
    dseVec: DseVector,
    config: Map[String, String]
  ): Vector[FacsimilePage] = {

    val howMany: Int = surfaceUrns.size

    surfaceUrns.zipWithIndex.map( su => {
      val urn: Cite2Urn = su._1
      val fileName: String = urnToFileName(urn)
      val surfaceObj: CiteObject = colls.citableObject(urn)
      val title: String = surfaceObj.label
      val index: Int = su._2
      val prevFile: Option[String] = {
        if (index > 0) {
          val prevUrn = surfaceUrns(index - 1)
          Some(urnToFileName(prevUrn))
        } else {
          None
        }
      }
      val prevLabel: Option[String] = {
        if (index > 0) {
          val prevUrn = surfaceUrns(index - 1)
          val prevObj: CiteObject = colls.citableObject(urn)
          Some(prevObj.label)
        } else {
          None
        }
      }
      val nextFile: Option[String] = {
        if (index < (surfaceUrns.size - 1)) {
          val nextUrn = surfaceUrns(index + 1)
          Some(urnToFileName(nextUrn))
        } else {
          None
        }
      }
      val nextLabel: Option[String] = {
        if (index < (surfaceUrns.size - 1)) {
          val nextUrn = surfaceUrns(index + 1)
          val nextObj: CiteObject = colls.citableObject(urn)
          Some(nextObj.label)
        } else {
          None
        }
      }
      // Make the html for the page
      val html: String = simpleSurfaceHTML(
        urn,
        colls,
        corp,
        dseVec,
        config
      )
      FacsimilePage(
        html = html,
        prevFile = prevFile,
        prevLabel = prevLabel,
        nextFile = nextFile,
        nextLabel = nextLabel,
        howMany = howMany,
        index = index, 
        fileName = fileName,
        title = title
      )
    })

  }

  def simpleSurfaceHTML(
    surfaceUrn: Cite2Urn, 
    colls: CiteCollectionRepository,
    corp: Corpus,
    dseVec: DseVector,
    config: Map[String, String]
  ): String = {

      val surfaceObj: CiteObject = colls.citableObject(surfaceUrn)
      val surfaceLabel: String = surfaceObj.label
      println(s"\n------\nWorking on ${surfaceUrn}\n------")
      println("\tGetting text urns…")
      val textUrns: Vector[CtsUrn] = dseVec.textsForTbs(surfaceUrn)
      println("\tsorting text urns…")
      val sortedUrns: Vector[CtsUrn] = corp.sortPassages(textUrns)
      println("\ttwiddling text urns…")
      val textCorpus: Corpus = corp ~~ sortedUrns
      println("\tgrouping by text…")
      val byText: Vector[Corpus] = HtmlWriter.groupCorpusByText(textCorpus)
      val corporaHtml: String = {
        byText.map( t => {
          HtmlWriter.writeCorpus(t)
        }).mkString("\n\n")
      }
      print("\t…done.")
      corporaHtml
  }

  /** Working from the inside out, use templates to assemble
   *  an HTML page
   */
  def assembleHtml( facsObject: FacsimilePage, config: Map[String, String]): String = {
    // Get the templates
    val surfTempFile: String = config("surfaceTemplate")
    val surfTemp: String = utilities.loadFile(surfTempFile).mkString("\n")
    val htmlTempFile: String = config("htmlTemplate")
    val htmlTemp: String = utilities.loadFile(htmlTempFile).mkString("\n")
    val cssTempFile: String = config("cssTemplate")
    val cssTemp: String = utilities.loadFile(cssTempFile).mkString("\n")
    val jsTempFile: String = config("jsTemplate")
    val jsTemp: String = utilities.loadFile(jsTempFile).mkString("\n")

    // Navigation
    val navHtml: String = {
      val prevHtml: String = facsObject.prevFile match {
        case Some(f) => {
          s"""<span class="cts_prev"><a href="${f}"> ⇽ ${facsObject.prevLabel.getOrElse("")} </a></span>"""
        }
        case None => ""
      } 
      val nextHtml: String = facsObject.nextFile match {
        case Some(f) => {
          s"""<span class="cts_next"><a href="${f}"> ${facsObject.nextLabel.getOrElse("")} ⇾ </a></span>"""
        }
        case None => ""
      } 
      val middleStr: String = {
          if ( (facsObject.prevFile != None) && (facsObject.nextFile != None) ) " | " else ""
        }
      s"""<div class="cite_facs_nav">${prevHtml}${middleStr}${nextHtml}</div>"""
    }

    // Work inside to outside
    val surfaceHtml: String = surfTemp.replaceAll("CONTENT_HERE", facsObject.html)
    val htmlPage = htmlTemp.replaceAll("LABEL_HERE", facsObject.title)
                           .replaceAll("CSS_HERE", cssTemp)
                           .replaceAll("NAV_HERE", navHtml)
                           .replaceAll("CONTENT_HERE", facsObject.html)
                           .replaceAll("JS_HERE", jsTemp)
    htmlPage

  }

  /** Sort DSE Vector by Surface
   * 
   * Given a DseVector and a Collection Repository,
   * Divide DSE records by Collection, and
   * Sort each one by collection-sequence.
   */
   /*
  def sortBySurface( dv: DseVector, cr: CiteCollectionRepository ): Vector[DseVector] = {

  }
  */

  /** Sort DSE Vector by Text
   * 
   * Given a DseVector and a TextRepository 
   * Divide DSE records by text, and
   * Sort each one by text-order.
   */
   /*
  def sortByText( dv: DseVector, tr: TextRepository ): Vector[DseVector] = {

  }
  */


  /** A function: Given a URN and a number, generate a file-name. */
  def urnToFileName( urn: Urn, index: Option[Int] = None ): String = {
    urn match {
      case CtsUrn(_) => {
          urnToFileName( urn.asInstanceOf[CtsUrn], index )
      }
      case _ => {
          urnToFileName( urn.asInstanceOf[Cite2Urn], index )
      }
    }
  }
  def urnToFileName( urn: CtsUrn, index: Option[Int] ): String = {
  	val baseName: String = urn.workParts.mkString("_")
  	index match {
  		case Some(i) => {
  			s"${baseName}_${i}.html"
  		}
	  	case None => {
	  		s"${baseName}.html"
	  	}
  	}
  }
  def urnToFileName( urn: Cite2Urn, index: Option[Int] ): String = {
    val baseName: String = urn.toString.replaceAll(":","_").replaceAll("\\.","-")
    index match {
      case Some(i) => {
        s"${baseName}_${i}.html"
      }
      case None => {
        s"${baseName}.html"
      }
    }
  }


}
